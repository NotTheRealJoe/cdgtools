# cdgparse - cdgtools: CD+G Bin Parser

# Copyright (C) 2009  Kelvin Lawson (kelvinl@users.sf.net)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# OVERVIEW
#
# cdgparse is part of the cdgtools suite of CD+G karaoke software.
#
# This module can be used to parse the binary files generated by
# CD ripping programs such as cdrdao. The binary input file should
# be the full binary rip including RW subchannel data.
#
# The bin file is expected to contain consecutive sectors from the CD
# with each sector taking up 2448 bytes (2352 bytes audio data
# followed by 96 bytes subchannel data).
#
# This module has been developed and tested using bin files generated
# by cdrdao, but it should support the ripped binary files generated
# by other CD ripping software, as long as they follow the same
# format.
#
# If you want to use this with other ripping software, you need to 
# find out the start byte and length in bytes of the track(s) you
# would like to rip. You can then call bin2cdg() to get the CD+G
# data out. If the rip contains raw/interleaved subchannel data
# then you can pass the results from bin2cdg() into Deinterleave().
# Otherwise if the rip is already deinterleaved, then there is no
# more processing necessary. Once you have the block of deinterleaved
# CD+G data, you can save it out to a file using cdgWriteToFile().
#
# Audio ripping follows a similar scheme, but no deinterleave stage
# is required. Pass the track start byte and length into bin2pcm()
# to get the raw PCM audio data. You can write it out to a file
# using pcmWriteToFile(), and then encode the file to mp3 using
# lame or similar.
#
# Note that not all drives can return the subchannel data during
# ripping. If your drive supports one of the subchannel modes
# (raw interleaved, or deinterleaved), then it should be possible
# to use it together with cdgtools.
#
# See cdgrip.py for an example ripping application which utilises
# this module.
#
# For further details see http://www.kibosh.org/cdgtools/

import struct


# Offsets for deinterleaving, thanks to the author of karaoke-dx
offsets = ( 0, 66, 125, 191, 100, 50, 150, 175,
			8, 33, 58, 83, 108, 133, 158, 183,
			16, 41, 25, 91, 116, 141, 166, 75)


# Take the bin output from cdrdao and rip out the 96 subchannel
# bytes in each sector. Use start_offset and binsize to select
# particular tracks in the (entire CD) bin file. Also masks out
# any non-CDG (PQ) bits from each byte.
def bin2cdg (binfilename, start_offset, binsize):

	# Open the binfile and seek to the track start
	binfile = open (binfilename, "rb")
	binfile.seek (start_offset, 0)

	_cdgdata = []
	donesize = 0

	# Loop through each sector, skipping the 2352 bytes audio data, and 
	# ripping out out the 96 bytes subchannel data.
	while donesize < binsize:

		# Skip 2352 bytes from current location
		binfile.seek(2352, 1)
		donesize = donesize + 2352

		# Read 96 bytes subchannel data
		chunk = binfile.read(96)
		chunksize = len(chunk)
		if chunksize > 0:
			# Mask out the PQ data, only returning the R-W channels
			for unmasked in chunk:
				byte = struct.unpack("b", unmasked)[0]
				byte = byte & 0x3F
				masked = struct.pack("b", byte)
				_cdgdata.append(masked)
			donesize = donesize + chunksize
		else:
			break

	binfile.close()
	return (_cdgdata)

# Deinterleave subchannel data if read from the drive in raw mode
def Deinterleave (cdgdata):

	# Skip the last two sectors as we don't have the upcoming spread bytes
	sectors = (len(cdgdata) / 96) - 2
	deinterleavedData = []

	# Swap the byte positions to deinterleave the data
	for sector in range (sectors):
		for pack in range (4):
			for column in range (24):
				try:
					deinterleavedData.append(cdgdata[(sector * 96) + (pack * 24) + offsets[column]])
				except:
					print ("ERROR: Sector %d, Pack %d, column %d" % (sector, pack, column))

	return (deinterleavedData)


# Rip the raw audio data to a raw PCM file
def bin2pcm (binfilename, start_offset, binsize):

	# Open the binfile and seek to the track start
	binfile = open (binfilename, "rb")
	binfile.seek (start_offset, 0)

	_audiodata = []
	donesize = 0

	# Loop through each sector, reading the 2352 bytes audio data,
	# and skipping the 96 bytes subchannel data.
	while donesize < binsize:

		# Read 2352 bytes raw audio data
		chunk = binfile.read (2352)
		# Skip 96 bytes subchannel data
		binfile.seek (96, 1)

		chunksize = len(chunk)
		if chunksize > 0:
			_audiodata.append(chunk)
			donesize = donesize + chunksize + 96
		else:
			break

	binfile.close()
	return (_audiodata)


# Write the entire CDG data block out to a file
def cdgWriteToFile (cdgfilename, cdgdata):
	cdgfile = open (cdgfilename, "wb")
	for byte in cdgdata:
		cdgfile.write (byte)
	cdgfile.close()


# Write the entire PCM audio data block out to a file
def pcmWriteToFile (pcmfilename, pcmdata):
	pcmfile = open (pcmfilename, "wb")
	for byte in pcmdata:
		pcmfile.write (byte)
	pcmfile.close()
